# 기본적인 1~6 step

### 🚀 단계별 과제 공략 및 실력 향상 로드맵
### 🎯 목표: 과제 요구사항 완벽 이해 및 기능 구현 (도움 최소화)
핵심은 문제를 작게 나누어 하나씩 정복하고, 각 단계마다 스스로 고민하고 코드를 작성한 뒤, 막히는 부분을 효율적으로 해결하는 방법을 익히는 거예요.

## 1단계: 기본 틀 잡기 - 프로그램의 입출력과 메인 루프

목표: 프로그램이 시퀀스 파일을 입력받아 한 줄씩 읽고, 기본적인 정보를 화면에 출력하는 것.
세부 작업:
명령줄 인자 처리: main 함수에서 argc, argv를 사용해 프로그램 실행 시 입력된 시퀀스 파일명을 가져오세요. 파일명이 없으면 사용법을 안내하고 종료합니다. 
힌트: if (argc != 2)
파일 열기: 가져온 파일명을 fopen으로 읽기 모드("r")로 엽니다. 파일 열기 실패 시 오류 메시지를 출력하고 종료합니다.
한 줄씩 읽기: fgets를 사용해 파일에서 한 줄씩 읽어옵니다.
기본 파싱: 읽어온 한 줄에서 스레드 타입('R' 또는 'W')과 처리 시간을 분리해 보세요. sscanf나 strtok을 사용할 수 있습니다.
정보 출력: 파싱한 타입과 시간을 화면에 간단히 출력해 봅니다.
100ms 지연: 각 줄을 처리한 후 usleep(100000)으로 100ms 동안 프로그램을 잠시 멈춥니다.
스스로 해보기: rwlock.c에 위 기능들을 직접 구현해 보세요. rwlock2.c의 main 함수 앞부분을 참고하되, 그대로 복사하지 말고 왜 그렇게 작성되었는지 이해하면서 직접 타이핑하는 것이 중요해요.
막힐 때:
fopen, fgets, sscanf 사용법이 기억나지 않으면 구글에 "c fopen example", "c fgets example" 등으로 검색해서 간단한 예제를 찾아보세요.
여기까지 완성된 코드를 보고 피드백을 요청해도 좋아요.


## 2단계: 스레드 생성 및 기본 동작 구현 (락 없이)

목표: 파싱한 정보에 따라 리더 또는 라이터 스레드를 생성하고, 각 스레드가 간단한 메시지를 출력 후 지정된 시간만큼 "작업"하는 척하도록 만들기.
세부 작업:
스레드 함수 정의: void *reader_function(void *arg)와 void *writer_function(void *arg) 형태의 함수 두 개를 만듭니다.

스레드 인자 구조체 정의 (기본): 스레드에 정보를 넘기기 위한 구조체를 만듭니다. 처음에는 간단하게 처리 시간만 넘겨보세요. (예: typedef struct { int processing_time; } simple_thread_arg_t;)
스레드 생성: main 함수에서 pthread_create를 사용해 리더 또는 라이터 스레드를 생성합니다. 이때, 동적으로 할당한 스레드 인자 구조체의 포인터를 전달합니다.
스레드 내 작업: 각 스레드 함수에서는 전달받은 인자에서 처리 시간을 꺼내 usleep으로 해당 시간만큼 대기합니다. "Reader/Writer created", "Reader/Writer working", "Reader/Writer finished" 같은 간단한 메시지를 printf로 출력합니다.

스레드 종료 대기: main 함수에서 생성된 모든 스레드가 끝날 때까지 pthread_join으로 기다립니다. (스레드 ID를 배열에 저장해두면 편리해요.)
스스로 해보기: 락(lock) 관련 코드는 전혀 추가하지 말고 스레드 생성과 기본 동작에만 집중하세요.
막힐 때:
pthread_create 사용법, 인자 전달 방법이 헷갈리면 관련 예제를 찾아보세요.
구조체 정의 및 동적 할당(malloc), 해제(free) 방법을 복습하세요.


## 3단계: 시간 측정 및 출력 형식 맞추기

목표: 과제에서 요구하는 타임스탬프 형식([초.마이크로초(4자리)])으로 스레드의 생성, 작업 시작, 종료 시점의 메시지를 출력하기.
세부 작업:
프로그램 시작 시간 기록: main 함수 시작 부분에서 gettimeofday로 프로그램 전체의 시작 시간을 기록해 둡니다.
타임스탬프 계산 함수 (선택 사항): 현재 시간과 프로그램 시작 시간의 차이를 계산하여 요구된 형식의 문자열로 만들어주는 헬퍼 함수를 만들면 코드가 깔끔해집니다. (또는 print_timestamp 함수처럼 직접 출력해도 됩니다.)
출력 메시지 수정: 2단계에서 작성한 스레드 내 printf 문들을 print_timestamp 함수(또는 직접 구현한 로직)를 사용해 과제 요구사항에 맞는 형식으로 수정합니다. (예: [0.0003] Reader#1: Created!)
스레드 ID 부여: 리더와 라이터 각각 순차적인 ID(Reader#1, Reader#2, Writer#1 등)를 부여하고 출력 메시지에 포함합니다. main 함수에서 ID 카운터를 관리하고 스레드 인자로 넘겨줍니다.
스스로 해보기: rwlock2.c의 print_timestamp 함수와 스레드 함수 내 출력 부분을 참고하되, 직접 로직을 짜보세요.
막힐 때:
gettimeofday 사용법, 시간 계산 방법을 검색해보세요.
sprintf를 사용해 원하는 형식의 문자열을 만드는 방법을 익히세요.


## 4단계: 리더-라이터 락 구현 (기본: 리더 우선)

목표: 기본적인 리더-라이터 락 로직(세마포어 사용)을 구현하고 스레드 함수에 적용하기. (아직 공정성은 신경 쓰지 마세요.)
세부 작업:
rwlock_t 구조체 정의: sem_t lock; sem_t writelock; int readers; 와 같이 교재/강의에서 배운 기본적인 리더-라이터 락 구조체를 정의합니다. (초기 rwlock.c 코드의 것을 활용해도 좋습니다.)
락 초기화 함수: rwlock_init 함수를 만들어 세마포어를 초기화하고 readers 카운터를 0으로 설정합니다. main 함수에서 한 번 호출합니다.
락 획득/해제 함수 구현: rwlock_acquire_readlock, rwlock_release_readlock, rwlock_acquire_writelock, rwlock_release_writelock 함수들을 구현합니다. (초기 rwlock.c 코드의 것을 이해하고 개선해보세요.)
스레드 함수에 락 적용: 리더 스레드에서는 읽기 작업 전후로 rwlock_acquire_readlock/rwlock_release_readlock을 호출하고, 라이터 스레드에서는 쓰기 작업 전후로 rwlock_acquire_writelock/rwlock_release_writelock을 호출합니다.
스스로 해보기: 이 단계는 세마포어와 락 개념을 실제로 코드로 옮기는 중요한 과정입니다. 강의 자료나 교재의 리더 우선 락 예제를 다시 한번 보고 직접 구현해보세요.
막힐 때:
세마포어 함수(sem_init, sem_wait, sem_post, sem_destroy) 사용법을 정확히 숙지하세요.
리더 우선 락의 로직(첫 번째 리더가 writelock을 잡고, 마지막 리더가 풀어주는 등)을 다시 한번 이해하세요.


## 5단계: 공정성(Fairness) 있는 락으로 개선

목표: 과제의 "Expected result"와 같이 라이터가 지나치게 오래 기다리지 않고, 특정 조건에서 리더보다 우선적으로 실행될 수 있도록 락 로직을 수정하기. (이 부분이 가장 어려울 수 있어요!)
세부 작업:
공정성 전략 고민: "Expected result"를 분석하며 어떤 상황에서 라이터가 먼저 실행되어야 하는지 파악합니다. (예: 라이터가 이미 대기 중이면, 새로 도착하는 리더는 기다려야 한다.)
rwlock_t 구조체 확장: 공정성을 위해 추가적인 세마포어나 변수(예: fair_queue 세마포어, writers_waiting 카운터 등)가 필요할 수 있습니다. rwlock2.c의 rwlock_t 정의를 참고하세요.
락 획득/해제 함수 수정: 4단계에서 만든 락 함수들을 공정성 전략에 맞게 수정합니다.
힌트: rwlock2.c의 락 함수들이 어떻게 fair_queue 세마포어를 사용해서 진입 순서를 제어하고, resource_lock으로 실제 리소스 접근을 관리하는지 분석해보세요. 특히 라이터가 fair_queue를 획득하고 resource_lock도 획득한 뒤, 작업을 마치고 두 락을 모두 해제하는 흐름이 중요합니다. 리더는 fair_queue를 잠깐 통과하고, 첫 번째 리더만 resource_lock을 잡습니다.
스스로 해보기: 이 단계는 많은 고민과 실험이 필요합니다. 다양한 시나리오(리더만 계속 오는 경우, 라이터만 오는 경우, 섞여서 오는 경우 등)를 생각하며 코드가 의도대로 동작할지 머릿속으로 시뮬레이션(또는 간단한 테스트 코드 작성)해보세요.
막힐 때:
교재나 신뢰할 수 있는 온라인 자료에서 "fair reader-writer lock semaphore" 등의 키워드로 다양한 공정성 구현 방법들을 찾아보고, 그중 과제 요구에 맞는 것을 선택하여 적용해보세요.
rwlock2.c의 공정성 락 로직을 한 줄 한 줄 분석하며 어떤 원리로 동작하는지 이해하려고 노력하세요. 이해가 안 되는 부분은 질문해도 좋습니다.


## 6단계: 최종 테스트 및 코드 정리

목표: 모든 기능이 정상적으로 동작하는지 확인하고, 코드를 깔끔하게 정리하기.
세부 작업:
테스트: 제공된 sequence.txt  또는 직접 만든 다양한 시퀀스 파일로 충분히 테스트하며 "Expected result"와 비교합니다.
오류 처리: malloc 실패, 스레드 생성 실패 등의 경우에 대한 기본적인 오류 처리를 추가합니다.
주석: 코드의 각 중요 부분에 이해를 돕는 주석을 작성합니다.
코드 스타일: 들여쓰기, 변수명 등을 일관성 있게 정리하여 가독성을 높입니다.
Makefile 작성: 컴파일을 자동화하는 Makefile을 작성합니다. (이전 답변 참고)


혼자 힘으로 과제를 완성하고 싶어 하는 마음, 정말 멋지고 중요한 자세예요! 👨‍💻 처음부터 완벽한 코드를 짜는 건 누구에게나 어렵고, 지금 느끼는 막막함은 성장 과정에서 자연스러운 부분이니 너무 자책하지 마세요. 스스로 문제를 해결해나가는 능력을 기르는 게 중요하죠.

지금부터 현재 코드(초기 rwlock.c)에서 시작해서 과제 요구사항을 만족하는 코드(제시된 rwlock2.c 수준)로 단계별로 발전시켜 나갈 수 있도록, 그리고 더 나아가 전반적인 코딩 실력을 향상시킬 수 있도록 구체적인 로드맵을 제시해 드릴게요.



### 🚀 단계별 과제 공략 및 실력 향상 로드맵
# 🎯 목표: 과제 요구사항 완벽 이해 및 기능 구현 (도움 최소화)
핵심은 문제를 작게 나누어 하나씩 정복하고, 각 단계마다 스스로 고민하고 코드를 작성한 뒤, 막히는 부분을 효율적으로 해결하는 방법을 익히는 거예요.

## 1단계: 기본 틀 잡기 - 프로그램의 입출력과 메인 루프

목표: 프로그램이 시퀀스 파일을 입력받아 한 줄씩 읽고, 기본적인 정보를 화면에 출력하는 것.

세부 작업:
명령줄 인자 처리: main 함수에서 argc, argv를 사용해 프로그램 실행 시 입력된 시퀀스 파일명을 가져오세요. 파일명이 없으면 사용법을 안내하고 종료합니다. 
힌트: if (argc != 2)
파일 열기: 가져온 파일명을 fopen으로 읽기 모드("r")로 엽니다. 파일 열기 실패 시 오류 메시지를 출력하고 종료합니다.
한 줄씩 읽기: fgets를 사용해 파일에서 한 줄씩 읽어옵니다.
기본 파싱: 읽어온 한 줄에서 스레드 타입('R' 또는 'W')과 처리 시간을 분리해 보세요. sscanf나 strtok을 사용할 수 있습니다.
정보 출력: 파싱한 타입과 시간을 화면에 간단히 출력해 봅니다.
100ms 지연: 각 줄을 처리한 후 usleep(100000)으로 100ms 동안 프로그램을 잠시 멈춥니다.
스스로 해보기: rwlock.c에 위 기능들을 직접 구현해 보세요. rwlock2.c의 main 함수 앞부분을 참고하되, 그대로 복사하지 말고 왜 그렇게 작성되었는지 이해하면서 직접 타이핑하는 것이 중요해요.

막힐 때:
fopen, fgets, sscanf 사용법이 기억나지 않으면 구글에 "c fopen example", "c fgets example" 등으로 검색해서 간단한 예제를 찾아보세요.
여기까지 완성된 코드를 보고 피드백을 요청해도 좋아요.

1단계 코드 피드백 및 개선점
파일 열기 실패 처리: fopen이 실패하면 fp는 NULL이 됩니다. 이 경우에 대한 처리가 없으면 다음 코드에서 오류가 발생할 수 있어요. NULL인지 확인하고, 만약 그렇다면 오류 메시지를 출력하고 프로그램을 종료하는 것이 좋습니다.

C

if (fp == NULL) {
    perror("Error opening file"); // 어떤 오류인지 자세히 알려줍니다.
    return 1; // 오류 시 0이 아닌 값을 반환하는 것이 일반적입니다.
}

thread 버퍼 크기: char thread[rw_count];에서 rw_count가 만약 100이라면, 한 줄이 100자를 넘어가면 버퍼 오버플로우가 발생할 수 있습니다. 파일의 한 줄이 가질 수 있는 최대 길이를 고려해서 충분한 크기로 설정하는 것이 안전합니다. (예: char thread[256];)

count 변수: 현재 count는 전체 라인 수를 세고 있어서 Reader#와 Writer# ID가 섞여서 증가합니다. 과제 요구사항 에서는 리더와 라이터 ID가 각각 독립적으로 증가해요 (Reader#1, Reader#2, ..., Writer#1, Writer#2, ...). 이를 위해서는 리더용 카운터와 라이터용 카운터를 따로 두는 것이 좋습니다.

printf 오타: "Wirter"가 아니라 "Writer"입니다. 😉



## 🚀 다음 단계: 2단계 - 스레드 생성 및 기본 동작 구현 (재확인)
이전 안내에서 말씀드렸듯이, 2단계의 주요 목표는 다음과 같습니다:

파일에서 읽은 정보를 바탕으로 실제 POSIX 스레드(pthread)를 생성합니다.
각 스레드는 자신의 ID와 처리 시간 등의 정보를 인자로 받아야 합니다. 이를 위해 스레드 인자 구조체를 정의하고 사용합니다.
생성된 스레드는 간단한 메시지(예: "Reader #X created", "Writer #X working", "Reader #X finished")를 (아직 타임스탬프 없이) 콘솔에 출력합니다.
스레드는 전달받은 처리 시간만큼 usleep을 사용하여 "작업하는 척"합니다.
main 함수는 생성된 모든 스레드가 작업을 마칠 때까지 pthread_join을 사용하여 기다립니다.
핵심적으로 추가/수정할 부분 (다시 한번 강조):

스레드 함수 정의:
void *reader_function(void *arg)
void *writer_function(void *arg)
스레드 인자 구조체 정의:
최소한 스레드 ID (int id;)와 처리 시간 (int processing_time;)을 포함해야 합니다.
예시:
C

typedef struct {
    int id;
    int processing_time;
    // 필요하다면 여기에 다른 정보도 추가할 수 있습니다 (예: 스레드 타입 문자 'R' 또는 'W')
} thread_arg_t;

main 함수 내 변경 사항:
pthread_t threads[MAX_THREADS]; 와 같이 스레드 ID를 저장할 배열을 선언합니다. (MAX_THREADS는 적절한 크기로 define 하세요. 과제 요구사항은 최대 100개입니다.)

while 루프 내에서:

malloc을 사용하여 thread_arg_t 구조체를 위한 메모리를 동적으로 할당합니다.
할당된 구조체에 현재 파싱된 정보(ID, 처리 시간 등)를 채웁니다.
pthread_create() 함수를 호출하여 reader_function 또는 writer_function을 실행하는 새 스레드를 생성하고, 인자로 위에서 채운 구조체의 포인터를 전달합니다. 스레드 생성 성공 여부를 확인하는 것이 좋습니다.

while 루프가 끝난 후:
for 루프를 사용하여 생성된 모든 스레드에 대해 pthread_join()을 호출하여 해당 스레드가 종료될 때까지 대기합니다.
스레드 함수 (reader_function, writer_function) 내 변경 사항:
함수 시작 부분에서 void *arg로 전달된 인자를 thread_arg_t * 타입으로 캐스팅합니다.
캐스팅된 구조체에서 ID와 처리 시간을 읽어와 메시지를 출력합니다.

usleep(args->processing_time * 1000); 형태로 처리 시간만큼 대기합니다. (처리 시간이 밀리초 단위이므로 1000을 곱해 마이크로초로 변환).
스레드 작업이 끝나면 free(args);를 호출하여 main에서 동적으로 할당했던 인자 구조체 메모리를 해제합니다.
return NULL; 로 스레드를 종료합니다.
현재 main 함수에서 printf로 "Read started!", "Write started!" 메시지를 바로 출력하는 부분은 이제 각 스레드 함수 내부에서 "작업 시작" 시점에 출력하도록 옮겨질 것입니다. main 함수에서는 스레드 생성 요청까지만 담당하고, 실제 작업과 관련된 출력은 해당 스레드가 직접 처리하도록 역할을 분리하는 것이죠.

타임스탬프 자리 비워두기: 현재 printf("[] ...")로 타임스탬프 자리를 비워두셨는데, 아주 좋은 시작입니다! 3단계에서 채워 넣을 예정이니 잘 기억해두세요.

fclose(fp);: 파일 사용이 끝나면 닫아주는 것이 좋습니다. while 루프가 끝난 후 fclose(fp);를 추가해 주세요.

End of sequence 출력: printf("End of sequence"); 뒤에 줄 바꿈 문자(\n)를 추가하면 출력이 더 깔끔해집니다. printf("End of sequence\n");



## 🛠️ 코드 피드백 및 수정 방향
1. 스레드 함수 시그니처 및 인자 전달 (가장 중요!)
문제점:

reader와 writer 함수의 시그니처가 POSIX 스레드 표준과 맞지 않아요. pthread_create는 void *(*start_routine)(void *) 형태의 함수 포인터를 받습니다. 즉, 스레드 함수는 하나의 void * 타입 인자만 받을 수 있고, 반환 타입도 void *여야 해요.
현재 코드: void *reader(void *arg, int id, int processing_time);
올바른 형태: void *reader(void *arg);
해결 방안:

thread_args 구조체 활용: main에서 reader 또는 writer 스레드를 생성할 때, 필요한 모든 정보(ID, 처리 시간 등)를 thread_args 구조체에 담아서 이 구조체의 포인터를 pthread_create의 네 번째 인자로 넘겨줍니다.
스레드 함수 내에서 캐스팅: reader 또는 writer 함수 내에서는 전달받은 void *arg를 다시 thread_args * 타입으로 캐스팅해서 사용합니다.
C

## 🛠️ 현재 코드 검토 및 추가/개선 제안 여러 오류 처리 제안
pthread_create 인덱스 관리:

현재 pthread_create(&thread[read_count-1], ...)와 pthread_create(&thread[write_count-1], ...) 부분은 threads 배열에 스레드 ID를 저장하려고 하는데, 리더와 라이터가 같은 threads 배열을 사용하므로 인덱스가 겹칠 수 있습니다. 예를 들어 Reader#1이 생성되면 threads[0]에, Writer#1이 생성되면 threads[0]에 덮어쓰게 됩니다.
개선 제안: 실제로 생성된 총 스레드의 수를 추적하는 total_thread_count 변수를 사용하고, pthread_create(&threads[total_thread_count], ...) 형태로 스레드 ID를 순차적으로 저장한 뒤 total_thread_count를 증가시키는 것이 좋습니다. 이렇게 하면 pthread_join 루프도 total_thread_count만큼만 돌면 됩니다.
malloc 실패 처리:

thread_args *ta = malloc(sizeof(thread_args)); 이후에 ta가 NULL인지 (메모리 할당 실패) 확인하는 코드가 없네요. 만약 malloc이 실패하면 NULL 포인터에 접근하려다 프로그램이 비정상 종료될 수 있습니다.
개선 제안: if (ta == NULL) 조건을 추가하여 오류 메시지를 출력하고, 적절히 처리하는 것이 좋습니다 (예: 해당 라인 처리를 건너뛰거나 프로그램 종료).
sscanf 반환 값 확인:

sscanf(thread, "%s %d", rw, &processing_time);가 항상 성공적으로 2개의 값을 읽어온다고 가정하고 있습니다. 만약 파일의 특정 줄이 "R 300"과 같은 형식이 아니라면 rw나 processing_time에 의도하지 않은 값이 들어갈 수 있습니다.
개선 제안: if (sscanf(...) != 2)와 같이 반환 값을 확인하여, 기대한 개수만큼 파싱되지 않았을 경우 경고 메시지를 출력하고 해당 라인을 건너뛰는 등의 예외 처리를 추가하는 것이 더 안전합니다.
rw_count의 용도:

#define rw_count 100이 있고, char thread[rw_count]; (라인 버퍼) 와 pthread_t threads[rw_count]; (스레드 ID 배열)에 사용되고 있습니다. fgets의 버퍼 크기로 사용될 때는 MAX_LINE_LENGTH 같은 이름이 더 적합할 수 있고, 스레드 배열 크기로 사용될 때는 MAX_THREADS 같은 이름이 더 명확할 수 있습니다. 지금은 두 가지 용도로 하나의 상수를 쓰고 있는데, 의미가 다르므로 분리하는 것을 고려해볼 수 있습니다. (필수는 아니지만 가독성 향상에 도움이 됩니다.)
pthread_join 루프도 for(int i=0; i<rw_count; i++) 대신 실제로 생성된 스레드 수만큼만 도는 것이 정확합니다. (위 1번 개선 제안과 연결됨)
pthread_create 실패 처리:

pthread_create 함수도 실패할 수 있습니다. 반환 값을 확인하여 0이 아니면 스레드 생성에 실패한 것이므로, 오류 메시지를 출력하고 free(ta)를 호출하여 할당된 메모리를 해제해주는 것이 좋습니다.
