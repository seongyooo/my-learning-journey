혼자 힘으로 과제를 완성하고 싶어 하는 마음, 정말 멋지고 중요한 자세예요! 👨‍💻 처음부터 완벽한 코드를 짜는 건 누구에게나 어렵고, 지금 느끼는 막막함은 성장 과정에서 자연스러운 부분이니 너무 자책하지 마세요. 스스로 문제를 해결해나가는 능력을 기르는 게 중요하죠.

지금부터 현재 코드(초기 rwlock.c)에서 시작해서 과제 요구사항을 만족하는 코드(제시된 rwlock2.c 수준)로 단계별로 발전시켜 나갈 수 있도록, 그리고 더 나아가 전반적인 코딩 실력을 향상시킬 수 있도록 구체적인 로드맵을 제시해 드릴게요.

🚀 단계별 과제 공략 및 실력 향상 로드맵
🎯 목표: 과제 요구사항 완벽 이해 및 기능 구현 (도움 최소화)
핵심은 문제를 작게 나누어 하나씩 정복하고, 각 단계마다 스스로 고민하고 코드를 작성한 뒤, 막히는 부분을 효율적으로 해결하는 방법을 익히는 거예요.

1단계: 기본 틀 잡기 - 프로그램의 입출력과 메인 루프

목표: 프로그램이 시퀀스 파일을 입력받아 한 줄씩 읽고, 기본적인 정보를 화면에 출력하는 것.
세부 작업:
명령줄 인자 처리: main 함수에서 argc, argv를 사용해 프로그램 실행 시 입력된 시퀀스 파일명을 가져오세요. 파일명이 없으면 사용법을 안내하고 종료합니다. 
힌트: if (argc != 2)
파일 열기: 가져온 파일명을 fopen으로 읽기 모드("r")로 엽니다. 파일 열기 실패 시 오류 메시지를 출력하고 종료합니다.
한 줄씩 읽기: fgets를 사용해 파일에서 한 줄씩 읽어옵니다.
기본 파싱: 읽어온 한 줄에서 스레드 타입('R' 또는 'W')과 처리 시간을 분리해 보세요. sscanf나 strtok을 사용할 수 있습니다.
정보 출력: 파싱한 타입과 시간을 화면에 간단히 출력해 봅니다.
100ms 지연: 각 줄을 처리한 후 usleep(100000)으로 100ms 동안 프로그램을 잠시 멈춥니다.
스스로 해보기: rwlock.c에 위 기능들을 직접 구현해 보세요. rwlock2.c의 main 함수 앞부분을 참고하되, 그대로 복사하지 말고 왜 그렇게 작성되었는지 이해하면서 직접 타이핑하는 것이 중요해요.
막힐 때:
fopen, fgets, sscanf 사용법이 기억나지 않으면 구글에 "c fopen example", "c fgets example" 등으로 검색해서 간단한 예제를 찾아보세요.
여기까지 완성된 코드를 보고 피드백을 요청해도 좋아요.

1단계 코드 피드백 및 개선점
파일 열기 실패 처리: fopen이 실패하면 fp는 NULL이 됩니다. 이 경우에 대한 처리가 없으면 다음 코드에서 오류가 발생할 수 있어요. NULL인지 확인하고, 만약 그렇다면 오류 메시지를 출력하고 프로그램을 종료하는 것이 좋습니다.

C

if (fp == NULL) {
    perror("Error opening file"); // 어떤 오류인지 자세히 알려줍니다.
    return 1; // 오류 시 0이 아닌 값을 반환하는 것이 일반적입니다.
}
thread 버퍼 크기: char thread[rw_count];에서 rw_count가 만약 100이라면, 한 줄이 100자를 넘어가면 버퍼 오버플로우가 발생할 수 있습니다. 파일의 한 줄이 가질 수 있는 최대 길이를 고려해서 충분한 크기로 설정하는 것이 안전합니다. (예: char thread[256];)

count 변수: 현재 count는 전체 라인 수를 세고 있어서 Reader#와 Writer# ID가 섞여서 증가합니다. 과제 요구사항 에서는 리더와 라이터 ID가 각각 독립적으로 증가해요 (Reader#1, Reader#2, ..., Writer#1, Writer#2, ...). 이를 위해서는 리더용 카운터와 라이터용 카운터를 따로 두는 것이 좋습니다.

printf 오타: "Wirter"가 아니라 "Writer"입니다. 😉



## 🚀 다음 단계: 2단계 - 스레드 생성 및 기본 동작 구현 (재확인)
이전 안내에서 말씀드렸듯이, 2단계의 주요 목표는 다음과 같습니다:

파일에서 읽은 정보를 바탕으로 실제 POSIX 스레드(pthread)를 생성합니다.
각 스레드는 자신의 ID와 처리 시간 등의 정보를 인자로 받아야 합니다. 이를 위해 스레드 인자 구조체를 정의하고 사용합니다.
생성된 스레드는 간단한 메시지(예: "Reader #X created", "Writer #X working", "Reader #X finished")를 (아직 타임스탬프 없이) 콘솔에 출력합니다.
스레드는 전달받은 처리 시간만큼 usleep을 사용하여 "작업하는 척"합니다.
main 함수는 생성된 모든 스레드가 작업을 마칠 때까지 pthread_join을 사용하여 기다립니다.
핵심적으로 추가/수정할 부분 (다시 한번 강조):

스레드 함수 정의:
void *reader_function(void *arg)
void *writer_function(void *arg)
스레드 인자 구조체 정의:
최소한 스레드 ID (int id;)와 처리 시간 (int processing_time;)을 포함해야 합니다.
예시:
C

typedef struct {
    int id;
    int processing_time;
    // 필요하다면 여기에 다른 정보도 추가할 수 있습니다 (예: 스레드 타입 문자 'R' 또는 'W')
} thread_arg_t;
main 함수 내 변경 사항:
pthread_t threads[MAX_THREADS]; 와 같이 스레드 ID를 저장할 배열을 선언합니다. (MAX_THREADS는 적절한 크기로 define 하세요. 과제 요구사항은 최대 100개입니다.)
while 루프 내에서:
malloc을 사용하여 thread_arg_t 구조체를 위한 메모리를 동적으로 할당합니다.
할당된 구조체에 현재 파싱된 정보(ID, 처리 시간 등)를 채웁니다.
pthread_create() 함수를 호출하여 reader_function 또는 writer_function을 실행하는 새 스레드를 생성하고, 인자로 위에서 채운 구조체의 포인터를 전달합니다. 스레드 생성 성공 여부를 확인하는 것이 좋습니다.
while 루프가 끝난 후:
for 루프를 사용하여 생성된 모든 스레드에 대해 pthread_join()을 호출하여 해당 스레드가 종료될 때까지 대기합니다.
스레드 함수 (reader_function, writer_function) 내 변경 사항:
함수 시작 부분에서 void *arg로 전달된 인자를 thread_arg_t * 타입으로 캐스팅합니다.
캐스팅된 구조체에서 ID와 처리 시간을 읽어와 메시지를 출력합니다.
usleep(args->processing_time * 1000); 형태로 처리 시간만큼 대기합니다. (처리 시간이 밀리초 단위이므로 1000을 곱해 마이크로초로 변환).
스레드 작업이 끝나면 free(args);를 호출하여 main에서 동적으로 할당했던 인자 구조체 메모리를 해제합니다.
return NULL; 로 스레드를 종료합니다.
현재 main 함수에서 printf로 "Read started!", "Write started!" 메시지를 바로 출력하는 부분은 이제 각 스레드 함수 내부에서 "작업 시작" 시점에 출력하도록 옮겨질 것입니다. main 함수에서는 스레드 생성 요청까지만 담당하고, 실제 작업과 관련된 출력은 해당 스레드가 직접 처리하도록 역할을 분리하는 것이죠.

타임스탬프 자리 비워두기: 현재 printf("[] ...")로 타임스탬프 자리를 비워두셨는데, 아주 좋은 시작입니다! 3단계에서 채워 넣을 예정이니 잘 기억해두세요.

fclose(fp);: 파일 사용이 끝나면 닫아주는 것이 좋습니다. while 루프가 끝난 후 fclose(fp);를 추가해 주세요.

End of sequence 출력: printf("End of sequence"); 뒤에 줄 바꿈 문자(\n)를 추가하면 출력이 더 깔끔해집니다. printf("End of sequence\n");
